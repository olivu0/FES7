// push - 배열의 뒤에 값을 추가한다
// return undefined
// pop - 뒤에서 값을 꺼내고 반환
// return 꺼낸 값

// unshift - 배열의 앞에 값을 추가한다
// return 배열의 길이
// shift - 앞에서 값을 꺼내고 반환
// return 꺼낸 값

// 문제
// push, pop, unshift, shift 이용해 다음과 같은 배열을 만들어보세요
// 입력값: [10, 20, 30, 40];
// 출력값: [10, 100, 20, 30, 50];
let arr = [10, 20, 30, 40];
arr.shift();
arr.unshift(100);
arr.unshift(10);
arr.pop();
arr.push(50);
// [10, 100, 20, 30, 50]

// 1. splice
let arr1 = [10, 20, 30];
arr1.splice(1, 0, 100); // 1번째에, 0개를 지우고, 100을 넣어라
// 삭제한 값이 없으므로 splice return 값이 빈 배열
arr1; // [10, 100, 20, 30]

let arr2 = [10, 20, 30];
arr2.splice(1, 1, 100, 200); // 1번째에, 1개를 지우고 100, 200을 넣어라

let arr3 = [10, 20, 30];
arr3.splice(1, 1, [100, 200]); // 1번째에, 1개를 지우고 [100, 200]을 넣어라

// array는 const로 선언한다

let arr4 = [10, 20, 30, 40];
let x = [1, 2, 3];
// return 값 [10, 1, 2, 3, 20, 30, 40, 1, 2, 3, 100]
arr4.splice(1, 0, x); // 원하는 값 나오지 않고 1, 2, 3이 배열이 묶어져서 나옴
// 전개구문, 스프레드 연산자
arr4.splice(1, 0, ...x); // [10, 1, 2, 3, 20, 30, 40]
arr4.splice(7, 0, ...x); // [10, 1, 2, 3, 20, 30, 40, 1, 2, 3]
arr4.push(100); // [10, 1, 2, 3, 20, 30, 40, 1, 2, 3, 100]

arr4.push(...x);
arr4.push(1, 2, 3);
arr4.push(...[1, , 2, 3]);

Math.max(10, 20, 30);
// 30;
Math.max(...[10, 20, 30]);
// 30;
Math.max([10, 20, 30]);
// NaN;

// splice에서 인자값을 하나만 넣으면, 그 인덱스부터 끝까지 다 지운다
// splice에서 인자값을 두개만 넣으면,

let arr5 = [10, 20, 30, 40];
arr5.splice(1); // 1번째부터 끝까지 다 지워라 return [20, 30, 40], arr5 [10]
arr5.splice(1, 2); // 1번째부터 2개 지워라 return [20, 30], arr5 [10, 40]

// 2. slice
// arr.slice(start, end)
// 주의! 원본은 수정되지 않는다
// splice는 원본을 수정한다
let arr6 = [10, 20, 30, 40];
arr6.slice(1, 3); // [20, 30]
arr6; // [10, 20, 30, 40]
arr6.slice(1, 100000); // 인덱스에 없는 값도 오류가 생기지 않는다 [20, 30, 40], splice도 마찬가지다
arr6.slice(100, 10000); // 오류 생기지 않는다 [], splice도 마찬가지다
